Help the King!

In the kingdom of Beluga, there are N cities connected by M
bidirectional roads. Each road has a maintenance cost. There is at least
one way to travel between any two cities.

The king is worried about the growing cost of maintaining all these roads.
To fix this, he asks his advisors for help.

The council suggests keeping only the roads needed to connect all the
cities with the least total maintenance cost. Instead of building new roads,
the king decides to save money by removing some of the existing ones.
# This sounds like a Minimum Spanning Tree (MST) problem.
# We need to select edges to connect all N cities with minimum total cost.
# Kruskal's algorithm or Prim's algorithm could work. Kruskal's seems
# straightforward with a DSU.

Since you're known for your programming skills, the king calls on you. He
wants you to figure out the minimum total maintenance cost that can be
achieved by removing some roads—while still making sure that all the
cities remain connected.

Input
The first line contains two integers
N, M(2 ≤ N ≤ 2 × 10^5, 1 ≤ M ≤ 3 × 10^5) — the number of
vertices, total number of edges.
# Standard N, M input.
# Python: n, m = map(int, input().split())

The next M lines will contain three integers
ui, vi, wi (1 ≤ ui, vi ≤ N, 1 ≤ wi ≤ 10^6) — there is an edge
between the node ui and the node vi with a maintenance cost wi.
# These are the roads. We'll need to store them, probably with their costs.
# For Kruskal's, it's best to store as (cost, u, v) for easy sorting.
# Python:
#   edges = []
#   for _ in range(m):
#       u, v, w = map(int, input().split())
#       edges.append((w, u, v))

Output
The output should contain a single integer, with the minimum total
maintenance cost achievable.

# Kruskal's Algorithm Plan:
# 1. Sort all edges by weight (cost) in ascending order.
#    Python: edges.sort()
# 2. Initialize a Disjoint Set Union (DSU) structure.
#    Each city is initially in its own set.
#    parent[i] = i, set_size[i] = 1
#    Python:
#       parent = list(range(n + 1)) # 1-indexed
#       set_size = [1] * (n + 1)
#       set_size[0] = 0 # Not used

#    DSU 'find' operation (with path compression):
#    def find_set(v_node):
#        if v_node == parent[v_node]:
#            return v_node
#        parent[v_node] = find_set(parent[v_node])
#        return parent[v_node]

#    DSU 'union' operation (by size):
#    # Returns True if union happened, False if already in same set.
#    def union_sets(a_node, b_node):
#        a_root = find_set(a_node)
#        b_root = find_set(b_node)
#        if a_root != b_root:
#            if set_size[a_root] < set_size[b_root]: # Attach smaller to larger
#                a_root, b_root = b_root, a_root
#            parent[b_root] = a_root
#            set_size[a_root] += set_size[b_root]
#            return True # Union performed
#        return False # Already in the same set

# 3. Iterate through sorted edges. For each edge (w, u, v):
#    If find(u) != find(v) (they are in different components):
#        Add edge to MST: mst_cost += w
#        Union(u, v)
#        Increment MST edge count.
#    Stop when MST edge count is N-1.
#    Python:
#       mst_cost = 0
#       edges_count_in_mst = 0
#       for cost, u, v in edges:
#           if edges_count_in_mst == n - 1: # MST is complete
#               break
#           if union_sets(u, v): # If u and v were in different sets
#               mst_cost += cost
#               edges_count_in_mst += 1

# The final mst_cost will be the answer.
# Python: # return str(mst_cost)

# Full structure might look like:
# def solve():
#     n, m = map(int, input().split())
#
#     parent = list(range(n + 1))
#     set_size = [1] * (n + 1)
#     set_size[0] = 0
#
#     def find_set(v_node):
#         if v_node == parent[v_node]:
#             return v_node
#         parent[v_node] = find_set(parent[v_node])
#         return parent[v_node]
#
#     def union_sets(a_node, b_node):
#         a_root = find_set(a_node)
#         b_root = find_set(b_node)
#         if a_root != b_root:
#             if set_size[a_root] < set_size[b_root]:
#                 a_root, b_root = b_root, a_root
#             parent[b_root] = a_root
#             set_size[a_root] += set_size[b_root]
#             return True
#         return False
#
#     edges = []
#     for _ in range(m):
#         u, v, w = map(int, input().split())
#         edges.append((w, u, v))
#
#     edges.sort()
#
#     mst_cost = 0
#     edges_count_in_mst = 0
#
#     for cost, u, v in edges:
#         if edges_count_in_mst == n - 1:
#             break
#         if union_sets(u, v):
#             mst_cost += cost
#             edges_count_in_mst += 1
#
#     return str(mst_cost)
#
# # To run it:
# # result = solve()
# # print(result)

# Example check:
# Input:
# 4 3
# 3 4 5
# 3 1 5
# 2 1 2
#
# N=4, M=3
# Edges: (5,3,4), (5,3,1), (2,2,1)
# Sorted Edges: (2,2,1), (5,3,1), (5,3,4)  <-- Note: My code uses (w,u,v) so (2,2,1) is correct for (cost 2, edge 2-1)
#
# 1. Edge (2, 2, 1): find(2)!=find(1). Union(2,1). mst_cost=2. count=1.
#    parent: [0,1,1,3,4] -> [0,1,1,3,4] (assume 1 becomes root of 2)
#    set_size: [0,2,1,1,1]
#
# 2. Edge (5, 3, 1): find(3)!=find(1). Union(3,1). mst_cost=2+5=7. count=2.
#    root of 3 is 3, root of 1 is 1.
#    parent: [0,1,1,1,4] (3's root 1 now points to 1)
#    set_size: [0,3,1,1,1] (size of 1's set becomes 2+1=3)
#
# 3. Edge (5, 3, 4): find(3)!=find(4). (find(3) is 1, find(4) is 4). Union(3,4). mst_cost=7+5=12. count=3.
#    root of 3 is 1, root of 4 is 4.
#    parent: [0,1,1,1,1] (4's root 4 now points to 1)
#    set_size: [0,4,1,1,1] (size of 1's set becomes 3+1=4)
#
# Count is 3 (N-1). Stop. Result: 12. Matches example.
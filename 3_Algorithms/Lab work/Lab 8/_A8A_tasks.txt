Friendship

There is a group of N people living in a small village. Each person in the
village has a unique identity — labeled with an integer value between 1
and N. Initially, the villagers don't have any friends. As time passes, they
begin to form friendships.

In this problem, you will be given information of K friendships. You have
to print an integer value that denotes the size of their friend circle.

Suppose five people are living in the village, labeled 1, 2, 3, 4, and 5.
Initially, the size of each friend circle is one, since no friendships have
been formed yet. One day, person 1 and person 2 become friends. So, the
size of their friend circle becomes two. The next day, person 3 and person
4 become friends, and the size of their friend circle becomes two as well.
After a few days, person 1 and person 4 become friends. Now, the size of
their combined friend circle becomes four, consisting of persons 1, 2, 3,
and 4.

Input
The first line contains two integers N, K (1 ≤ N, K ≤ 3 × 105) —
the total number of people, total number of friendship created.
 We'll need to read N and K first.
 Python: n, k = map(int, input().split())

The next K lines contain two integers
ai, aj(1 ≤ ai, aj ≤ N, ai ≠ aj) — two people become friends.

Output
For each friendship formation, output a single integer on a new line
representing the size of the friend circle that the two people belong to after
becoming friends.

 Initial thoughts on data structures:
 We need to keep track of who belongs to which group.
 A 'parent' array seems good, where parent[i] is the representative of i's group.
 Initially, everyone is their own parent: parent[i] = i.
 Python: parent = list(range(n + 1))  For 1-based indexing
 We also need the size of each group.
 Let's use 'set_size[i]' for the size of the group whose representative is i.
 Python: set_size = [1] * (n + 1)  Initially all size 1
 Python: set_size[0] = 0  Not using index 0

 We'll store results for each query.
 Python: results = []

 Core idea: Disjoint Set Union (DSU)
 Need a 'find' operation: given a person, find the representative of their circle.
 Path compression is key for efficiency here.
 Pseudo-code for find(v):
   if v is its own parent: return v
   else: parent[v] = find(parent[v]); return parent[v]
 Python:
   def find_set(v):
       if v == parent[v]:
           return v
       parent[v] = find_set(parent[v])  Path compression
       return parent[v]

 Need a 'union' operation: merge two circles.
 Union by size (or rank) is good for efficiency.
 When merging, the smaller set's root points to the larger set's root.
 Update the size of the new combined set.
 Python:
   def union_sets(a, b):
       a_root = find_set(a)
       b_root = find_set(b)
       if a_root != b_root:
            Union by size: make root of smaller set point to root of larger
           if set_size[a_root] > set_size[b_root]:  My original code had this swapped, correcting.
               parent[b_root] = a_root
               set_size[a_root] += set_size[b_root]
           else:  If sizes are equal or b_root's set is larger
               parent[a_root] = b_root
               set_size[b_root] += set_size[a_root]
        Regardless of whether a union happened or not,
        the size of the (potentially merged) set containing 'a' is what we need.
       return set_size[find_set(a_root)]  Or find_set(b), they are now in the same set.

 Main loop for processing K friendships:
 For each friendship (p1, p2):
   Read p1, p2.
   current_circle_size = union_sets(p1, p2)
   Add current_circle_size to results.
 Python:
   for _ in range(k):
       p1, p2 = map(int, input().split())
        The original problem's logic for appending was slightly different,
        my code for union_sets already returns the size needed.
       results.append(str(union_sets(p1, p2)))

 Finally, print all results, newline separated.
 Python:  return "\n".join(results) to be printed by a main caller.

 Full solution structure (mental draft):
 def solve():
     n, k = map(int, input().split())

     parent = list(range(n + 1))
     set_size = [1] * (n + 1)
     set_size[0] = 0

     results = []

     def find_set(v):  (as defined above)
         if v == parent[v]:
             return v
         parent[v] = find_set(parent[v])
         return parent[v]

     def union_sets(a, b):  (as defined above, returning the new size)
         a_root = find_set(a)
         b_root = find_set(b)
         if a_root != b_root:
             if set_size[a_root] > set_size[b_root]:
                 parent[b_root] = a_root
                 set_size[a_root] += set_size[b_root]
             else:
                 parent[a_root] = b_root
                 set_size[b_root] += set_size[a_root]
         return set_size[find_set(a)]  Size of the set containing 'a' (and 'b')

     for _ in range(k):
         p1, p2 = map(int, input().split())
         results.append(str(union_sets(p1, p2)))

     return "\n".join(results)

  To run it:
  output_str = solve()
  print(output_str)

 Example Trace: N=8, K=7
 input
 8 7
 2 4
 4 5
 3 6
 4 7
 3 1
 2 7
 6 2

 Output should be:
 2
 3
 2
 4
 3
 4
 7
 This matches the example logic. The DSU with union-by-size and path compression
 correctly models the merging friend circles and their sizes.